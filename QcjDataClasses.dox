/*!

\mainpage QcjDataClass Package.

\section intro Overview of the package

This package provides a class framework for building database applications
quickly and easily. The classes have been formulated with the idea that the
QcjData should be entered and modified in forms. Table views are provided for
representing and selecting the entire data set for the table. Quite often
it is convenient to provide an sql view to use in the table view and link
it to a form which manipulates a single record of the actual table.

The resulting programs can then be readily customized by the end user by
changing an XML file for the application. The XML file specifies what
tables and fields are displayed on what forms or tables (table views not
QcjDatabase tables). The XML files also specify the configuration items to
present to the user as well as help strings and other resources.

There are currently four main widgets this application provides. Other
widgets are available as well, but the intention is for them to be used by the
main four widgets.

Each of the following objects in both categories require a section in the
xml file to describe the mapping of the data in the application (database
or configuration) to the screen or report. The definitions lets you assign
human readable lables to the fields as well as define they're placement.

\section widgetObjects Widgets for Displaying and Manipulating Records

\li \c QcjDataForm A QFrame widget for holding elements for a single record of
the database. The contents of the record can be manipulated, a new record
created, and an existing record can be deleted using this widget.

\li \c QcjDataKeyValue A QFrame widget which will display and allow
modifications to tables which have one field which acts as a named key and
another field which acts as the value. The data types for both fields are
required to be either <em>char</em> or <em>varchar</em>. They can be used
to represent and use appropriate controls all of the field types which can
be specified on a QcjDataForm.

\li \c QcjDataTable A QFrame holding a QTableView for selecting one or more 
of multiple  records in the database. This widget allows you to sort 
on multiple columns, search for a record with specific data in the fields,
filter on data contents. The internals of the table are accessible to be
able to perform bulk actions on multiple records.

\li \c QcjDataSheet A QTextBrowser widget for displaying multiple records in
a nicely formatted fashion. This widget does not allow data manipulation 
by the user, no ordering or filtering by the user either. It does provide 
ordering and filtering with by program.

\li \c QcjPhotoFrame This is a QFrame which will show one or more photos
saved in a table in the database. They can have other fields in the record
displayed as text with the photos as well.

\section otherObjects Other widgets and objects for Configuration data and
reports.

\li \c QcjDataConfigure This dialog provides an interface for the user to set
configuration values for the application. Help displayed can be provided in
the XML document for each item to provide the user with guidance of what
and how the setting acts on the application.

\li \c QcjDataReport This dialog displays reports. Queries can be built
parameters can be provided and a nicely formatted report will be generated
for the user. This report can then either be printed or saved as a pdf
file.

\section usage Application integration and integration into the Designer

To use the code in your project, It should reside in a directory called QcjData 
in the source directory of your application. You then just need to add
the files for it into the .pro file used to build you application.

To integrate it into the Qt \a designer, There are several .pro files in the
QcjData directory. Run <em>qmake &lt;name&gt;.pro; make</em> for each one.
This will build and place their plugins into the appropriate directory for
the desinger to see them. Be sure you have proper permissions for
\a designer's plugin directory. If all went well, when you start \a designer
you will find a category named <em>QcjData Widget</em> with the available
widgets listed in it.

\section download Download

This project is hosted on <a href="http://www.linuxlots.com">LinuxLots</a> and the latest download as well as
older version can be downloaded from there. Follow this link 
<a href="ftp://ftp.linuxlots.com/pub/qcj">ftp://ftp.linuxlots.com/pub/qcj</a>
to get the code!

\section primarykeys Primary Keys in Records

By default, all of the form and table widgets in this package rely on each database
table to have a primary key field that is an integer which is
auto-generated by the database engine.

In the case of the <em>PostgreSQL</em> database, this field should be
named and declared as 

<code>ident serial primary key</code>

For MySql the primary key should be named as 

<code>id int auto_increment primary key</code>

For Sqlite the primary key should be named as 

<code>id integer primary key autoincrement</code>.

This is just a rule. Other forms of primary keys can be defined using the
&lt;key_generator&gt; section for the form. In this way, simple increments
or other means through sql can be used.

<code>
   <key_generator>
      <![CDATA[ select max(somekey) + 1 from sometable ]]>
   </key_generator>
</code>

\section signals_slots Signals and Slots

In most applications there will be dependencis between the objects. So far
the typical model for a database record has been to have a QcjDataTable to
select a record from associated with a QcjDataForm for manipulating the
individual record. The association is made through the signals and slots.
The most common model has been to tie the QcjDataTable signal 
rowSelected(QSqlRecord *) to the QcjDataForm slot 
refresh(QSqlRecord *), and to tie the QcjDataForm signal updated() to the
QcjDataTable slot refresh(). These connections can be made with 
\a designer if desired.

It is important that the form and table widgets have their database
configured by calling \a setDatabase before the other member functions of
their classes are called. Typically, for the case where there is a form
widget and table widget for a database table, the \a setDatabase function
should be called for a form before it is called for the corresponding
table. This is because the \a setDatabase function of the table will call
refresh and this will cause the signal \a rowSelected to be emitted which
then typically is connected to the slot \a refresh of the form widget. If
the form widget is not configured yet, this will case the application to
crash.

The above is important to remember when you are using \a designer to
connect the signals and slots between the objects. When you have
\a designer make the connections, the connections are made before any of your code is
run.

Sometimes, the dependancies between objects become complex such as when
selecting a row from one table widget sets a filter on a different table
widget. It is important to call the \c setDatabase functions of the objects
in the correct order, or create the connections between the objects
yourself after all of the \a setDatabase functions are called. If you
choose the latter approach, you will need to call refresh on the objects
tobring them up todate.

\section deployment Deploying Application built using QcjData classes

There are just a couple of requirements beyond those needed for deplying
any application built on Qt. The Qt requirements can be found here at 
http://doc.trolltech.com/4.5/deployment.html.

\subsection linuxdeployment Linux Deplyments

On startup the application needs to be able to find the XML definition file as
well as any reports. To find the XML file the following files will be
looked for in order:

- ~<user>/.<app_name>.xml
- ./<app_name>.xml
- ~<user>/.xml/<app_name>.xml
- /opt/<app_name>/default_forms.xml
- <app_path>/<app_name>.xml
- <app_path>/../<app_name>.xml

To find the reposrts the following directories will be looked for in order:

- ~<user>/.<app_name>/reports
- <app_path>/reports
- <app_path>/../reports
- /opt/<app_name>/reports
- <app_path>

The first file found will be the XML definition file used and it will be
assumed that any reports will be found in the first directory found.

This scheme allows for system wide deployments where users can be given
there own special configurations if needed. A typical installation would
be to have an application directory in \a /opt/&lt;app_name&gt; in which the
configuration file is named \a /opt/&lt;app_name&gt;/default_forms.xml and its
reports are in the directory \a /opt/&lt;app_name&gt;/reports and the executible
itself is in \a /opt/&lt;app_name&gt;/bin/&lt;app_name&gt;.

An alternative for a single user environment is to an application directory
with a similar layour under the users home directory. The difference would
be that the XML file itself would be name \a \&lt;app_name\&gt.xml.

\subsection windowsdeployment Windows Deployment

Under Windows, the same directory paths and such are searched for as with
the Linux deployments. Though typically, the application will have its own
directory (not /opt) and the configuration file would be named either
\a &lt;app_path&gt;\\&lt;app_name&gt;.xml or
\a &lt;app_path&gt;\\..\\&lt;app_name&gt;.xml.

\subsection osxdeployment Mac OSX Deployment

There is no reason that the applications cannot be built and deployed for
Mac OSX platforms. Unfortunately, at this time I have no way of know what
steps it will take.

*/
